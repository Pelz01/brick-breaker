<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Neon Brick Breaker</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Orbitron:wght@400;700&display=swap');

        body {
            margin: 0;
            overflow: hidden;
            background-color: #050505;
            color: white;
            font-family: 'Orbitron', sans-serif;
            touch-action: none; /* Prevent pull-to-refresh on mobile */
        }

        #game-container {
            position: relative;
            width: 100vw;
            height: 100vh;
            display: flex;
            justify-content: center;
            align-items: center;
            background: radial-gradient(circle at center, #1a1a2e 0%, #000000 100%);
        }

        canvas {
            box-shadow: 0 0 50px rgba(0, 255, 255, 0.1);
            background-color: rgba(0, 0, 0, 0.8);
            border: 2px solid #333;
            border-radius: 4px;
        }

        .ui-layer {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            display: flex;
            flex-direction: column;
            justify-content: space-between;
            padding: 20px;
        }

        .overlay {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.7);
            backdrop-filter: blur(5px);
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            pointer-events: auto;
            transition: opacity 0.3s ease;
            z-index: 10;
        }

        .hidden {
            opacity: 0;
            pointer-events: none;
        }

        .btn {
            background: transparent;
            color: #0ff;
            border: 2px solid #0ff;
            padding: 15px 40px;
            font-size: 1.5rem;
            font-family: 'Orbitron', sans-serif;
            cursor: pointer;
            text-transform: uppercase;
            letter-spacing: 2px;
            box-shadow: 0 0 15px rgba(0, 255, 255, 0.3);
            transition: all 0.2s;
            border-radius: 4px;
            margin-top: 20px;
        }

        .btn:hover {
            background: #0ff;
            color: #000;
            box-shadow: 0 0 30px rgba(0, 255, 255, 0.6);
        }

        .score-hud {
            text-shadow: 0 0 10px rgba(255, 255, 255, 0.5);
        }
    </style>
</head>
<body>

<div id="game-container">
    <canvas id="gameCanvas"></canvas>
    
    <!-- HUD -->
    <div class="ui-layer">
        <div class="flex justify-between w-full max-w-4xl mx-auto score-hud text-xl md:text-2xl">
            <div>SCORE: <span id="scoreEl">0</span></div>
            <div>LIVES: <span id="livesEl">3</span></div>
        </div>
    </div>

    <!-- Start Screen -->
    <div id="startScreen" class="overlay">
        <h1 class="text-4xl md:text-6xl font-bold text-transparent bg-clip-text bg-gradient-to-r from-cyan-400 to-purple-500 mb-4" style="filter: drop-shadow(0 0 10px rgba(0,255,255,0.5));">NEON BREAKER</h1>
        <p class="text-gray-300 mb-8 text-center max-w-md px-4">Drag to move paddle. Destroy all bricks.</p>
        <button class="btn" id="startBtn">START GAME</button>
    </div>

    <!-- Game Over Screen -->
    <div id="gameOverScreen" class="overlay hidden">
        <h2 class="text-5xl font-bold text-red-500 mb-2" style="text-shadow: 0 0 20px red;">GAME OVER</h2>
        <p class="text-2xl mb-6">Final Score: <span id="finalScore">0</span></p>
        <button class="btn" id="restartBtn">TRY AGAIN</button>
    </div>

    <!-- Victory Screen -->
    <div id="victoryScreen" class="overlay hidden">
        <h2 class="text-5xl font-bold text-green-400 mb-2" style="text-shadow: 0 0 20px lime;">VICTORY!</h2>
        <p class="text-2xl mb-6">Level Complete</p>
        <button class="btn" id="nextLevelBtn">NEXT LEVEL</button>
    </div>
</div>

<script>
/**
 * Game Configuration & Constants
 */
const GAME_WIDTH = 800;
const GAME_HEIGHT = 600;
const PADDLE_WIDTH = 100;
const PADDLE_HEIGHT = 16;
const BALL_RADIUS = 8;
const BRICK_ROWS = 6;
const BRICK_COLS = 9;
const BRICK_GAP = 10;
const PARTICLE_COUNT = 15;

// Colors
const COLORS = {
    paddle: '#0ff',
    ball: '#fff',
    background: '#000',
    bricks: [
        '#ef4444', // Red-500
        '#f97316', // Orange-500
        '#eab308', // Yellow-500
        '#22c55e', // Green-500
        '#3b82f6', // Blue-500
        '#a855f7'  // Purple-500
    ]
};

/**
 * Audio System (Synthesizer)
 * Generates sounds using Web Audio API to avoid external assets.
 */
const AudioSys = {
    ctx: null,
    
    init() {
        if (!this.ctx) {
            this.ctx = new (window.AudioContext || window.webkitAudioContext)();
        }
    },

    playTone(freq, type, duration, vol = 0.1) {
        if (!this.ctx) return;
        const osc = this.ctx.createOscillator();
        const gain = this.ctx.createGain();
        
        osc.type = type;
        osc.frequency.setValueAtTime(freq, this.ctx.currentTime);
        osc.frequency.exponentialRampToValueAtTime(freq * 0.5, this.ctx.currentTime + duration);
        
        gain.gain.setValueAtTime(vol, this.ctx.currentTime);
        gain.gain.exponentialRampToValueAtTime(0.01, this.ctx.currentTime + duration);
        
        osc.connect(gain);
        gain.connect(this.ctx.destination);
        
        osc.start();
        osc.stop(this.ctx.currentTime + duration);
    },

    playBounce() { this.playTone(300, 'sine', 0.1, 0.1); },
    playPaddle() { this.playTone(400, 'square', 0.1, 0.05); },
    playBreak() { this.playTone(150 + Math.random()*100, 'sawtooth', 0.15, 0.05); },
    playLoss() { this.playTone(100, 'sawtooth', 0.5, 0.2); },
    playWin() { 
        if(!this.ctx) return;
        // Simple arpeggio
        [0, 0.1, 0.2].forEach((delay, i) => {
            setTimeout(() => this.playTone(440 + (i*100), 'square', 0.2, 0.1), delay * 1000);
        });
    }
};

/**
 * Game State & Logic
 */
class Game {
    constructor() {
        this.canvas = document.getElementById('gameCanvas');
        this.ctx = this.canvas.getContext('2d');
        
        // Scaling logic
        this.scale = 1;
        this.resize();
        window.addEventListener('resize', () => this.resize());

        // Input state
        this.inputX = GAME_WIDTH / 2;
        this.setupInput();

        // Game Entities
        this.paddle = { x: GAME_WIDTH/2 - PADDLE_WIDTH/2, y: GAME_HEIGHT - 40, width: PADDLE_WIDTH, height: PADDLE_HEIGHT };
        this.ball = { x: GAME_WIDTH/2, y: GAME_HEIGHT/2, dx: 0, dy: 0, radius: BALL_RADIUS, active: false, speed: 6 };
        this.bricks = [];
        this.particles = [];
        
        // Game State
        this.score = 0;
        this.lives = 3;
        this.level = 1;
        this.state = 'MENU'; // MENU, PLAYING, GAMEOVER, VICTORY, PAUSE
        this.lastTime = 0;

        // UI Elements
        this.scoreEl = document.getElementById('scoreEl');
        this.livesEl = document.getElementById('livesEl');
        this.startScreen = document.getElementById('startScreen');
        this.gameOverScreen = document.getElementById('gameOverScreen');
        this.victoryScreen = document.getElementById('victoryScreen');
        this.finalScoreEl = document.getElementById('finalScore');

        // Bind UI Buttons
        document.getElementById('startBtn').addEventListener('click', () => {
            AudioSys.init();
            this.startGame();
        });
        document.getElementById('restartBtn').addEventListener('click', () => this.startGame());
        document.getElementById('nextLevelBtn').addEventListener('click', () => this.nextLevel());

        // Start Loop
        requestAnimationFrame(t => this.loop(t));
    }

    resize() {
        const aspect = GAME_WIDTH / GAME_HEIGHT;
        let w = window.innerWidth;
        let h = window.innerHeight;
        
        // Subtract some padding
        w -= 20;
        h -= 20;

        if (w / h > aspect) {
            w = h * aspect;
        } else {
            h = w / aspect;
        }

        this.canvas.width = GAME_WIDTH;
        this.canvas.height = GAME_HEIGHT;
        this.canvas.style.width = `${w}px`;
        this.canvas.style.height = `${h}px`;
        this.scale = w / GAME_WIDTH;
    }

    setupInput() {
        const updateInput = (clientX) => {
            const rect = this.canvas.getBoundingClientRect();
            // Map screen X to game X
            let val = (clientX - rect.left) / (rect.width / GAME_WIDTH);
            this.inputX = Math.max(0, Math.min(GAME_WIDTH, val));
        };

        // Mouse
        window.addEventListener('mousemove', e => updateInput(e.clientX));
        
        // Touch
        this.canvas.addEventListener('touchmove', e => {
            e.preventDefault();
            updateInput(e.touches[0].clientX);
        }, { passive: false });
        
        this.canvas.addEventListener('touchstart', e => {
            e.preventDefault();
            updateInput(e.touches[0].clientX);
            if (this.state === 'PLAYING' && !this.ball.active) {
                this.launchBall();
            }
        }, { passive: false });
        
        // Launch on click
        window.addEventListener('mousedown', () => {
            if (this.state === 'PLAYING' && !this.ball.active) {
                this.launchBall();
            }
        });
    }

    initLevel() {
        this.bricks = [];
        const offsetX = (GAME_WIDTH - (BRICK_COLS * (60 + BRICK_GAP))) / 2 + 35; // Rough centering
        const brickW = (GAME_WIDTH - (offsetX * 2) - ((BRICK_COLS - 1) * BRICK_GAP)) / BRICK_COLS;
        const brickH = 25;

        for (let r = 0; r < BRICK_ROWS; r++) {
            for (let c = 0; c < BRICK_COLS; c++) {
                // Skip some bricks for patterns in higher levels
                if(this.level > 1 && (r+c)%5 === 0) continue;

                this.bricks.push({
                    x: offsetX + c * (brickW + BRICK_GAP),
                    y: 60 + r * (brickH + BRICK_GAP),
                    w: brickW,
                    h: brickH,
                    color: COLORS.bricks[r % COLORS.bricks.length],
                    status: 1
                });
            }
        }
    }

    startGame() {
        this.score = 0;
        this.lives = 3;
        this.level = 1;
        this.updateHUD();
        this.resetBall();
        this.initLevel();
        this.state = 'PLAYING';
        
        this.hideOverlays();
    }

    nextLevel() {
        this.level++;
        this.lives++; // Bonus life
        this.ball.speed += 0.5;
        this.updateHUD();
        this.resetBall();
        this.initLevel();
        this.state = 'PLAYING';
        this.hideOverlays();
    }

    launchBall() {
        this.ball.active = true;
        this.ball.dy = -this.ball.speed;
        this.ball.dx = (Math.random() * 2 - 1) * this.ball.speed;
    }

    resetBall() {
        this.ball.active = false;
        this.ball.dx = 0;
        this.ball.dy = 0;
        this.ball.x = this.paddle.x + this.paddle.width/2;
        this.ball.y = this.paddle.y - this.ball.radius - 2;
    }

    createExplosion(x, y, color) {
        for(let i=0; i<PARTICLE_COUNT; i++) {
            this.particles.push({
                x: x, 
                y: y,
                dx: (Math.random() - 0.5) * 8,
                dy: (Math.random() - 0.5) * 8,
                life: 1.0,
                color: color,
                size: Math.random() * 3 + 1
            });
        }
    }

    update(dt) {
        if (this.state !== 'PLAYING') return;

        // 1. Paddle Movement
        // Lerp for smoothness
        const targetX = this.inputX - this.paddle.width / 2;
        this.paddle.x += (targetX - this.paddle.x) * 0.2; // Smooth catch-up
        
        // Clamp paddle
        if (this.paddle.x < 0) this.paddle.x = 0;
        if (this.paddle.x + this.paddle.width > GAME_WIDTH) this.paddle.x = GAME_WIDTH - this.paddle.width;

        // 2. Ball Logic
        if (!this.ball.active) {
            this.ball.x = this.paddle.x + this.paddle.width / 2;
            this.ball.y = this.paddle.y - this.ball.radius - 2;
        } else {
            this.ball.x += this.ball.dx;
            this.ball.y += this.ball.dy;

            // Walls
            if (this.ball.x + this.ball.radius > GAME_WIDTH) {
                this.ball.x = GAME_WIDTH - this.ball.radius;
                this.ball.dx *= -1;
                AudioSys.playBounce();
            }
            if (this.ball.x - this.ball.radius < 0) {
                this.ball.x = this.ball.radius;
                this.ball.dx *= -1;
                AudioSys.playBounce();
            }
            if (this.ball.y - this.ball.radius < 0) {
                this.ball.y = this.ball.radius;
                this.ball.dy *= -1;
                AudioSys.playBounce();
            }
            
            // Floor (Death)
            if (this.ball.y - this.ball.radius > GAME_HEIGHT) {
                this.lives--;
                AudioSys.playLoss();
                this.updateHUD();
                this.createExplosion(this.ball.x, this.ball.y, '#fff');
                if (this.lives <= 0) {
                    this.state = 'GAMEOVER';
                    this.finalScoreEl.innerText = this.score;
                    this.gameOverScreen.classList.remove('hidden');
                } else {
                    this.resetBall();
                }
            }

            // Paddle Collision
            // AABB Check
            if (this.ball.y + this.ball.radius >= this.paddle.y &&
                this.ball.y - this.ball.radius <= this.paddle.y + this.paddle.height &&
                this.ball.x >= this.paddle.x &&
                this.ball.x <= this.paddle.x + this.paddle.width) {
                
                // Only bounce if moving down
                if(this.ball.dy > 0) {
                    this.ball.dy = -this.ball.speed;
                    // Calculate angle based on hit position
                    let hitPoint = this.ball.x - (this.paddle.x + this.paddle.width/2);
                    // Normalize hit point (-1 to 1)
                    hitPoint = hitPoint / (this.paddle.width / 2);
                    
                    // Add curve effect
                    this.ball.dx = hitPoint * (this.ball.speed * 0.75);
                    AudioSys.playPaddle();
                    
                    // Add particles on paddle hit
                    this.createExplosion(this.ball.x, this.ball.y, '#0ff');
                }
            }

            // Brick Collision
            let activeBricks = 0;
            for (let b of this.bricks) {
                if (b.status === 1) {
                    activeBricks++;
                    if (this.ball.x > b.x && this.ball.x < b.x + b.w &&
                        this.ball.y > b.y && this.ball.y < b.y + b.h) {
                        
                        this.ball.dy *= -1;
                        b.status = 0;
                        this.score += 10 * this.level;
                        this.updateHUD();
                        AudioSys.playBreak();
                        this.createExplosion(this.ball.x, this.ball.y, b.color);
                    }
                }
            }
            
            if (activeBricks === 0) {
                this.state = 'VICTORY';
                AudioSys.playWin();
                this.victoryScreen.classList.remove('hidden');
            }
        }

        // 3. Particles
        for (let i = this.particles.length - 1; i >= 0; i--) {
            let p = this.particles[i];
            p.x += p.dx;
            p.y += p.dy;
            p.life -= 0.02;
            if (p.life <= 0) this.particles.splice(i, 1);
        }
    }

    draw() {
        // Clear
        this.ctx.fillStyle = '#050505'; // Slightly lighter than black to show trails better if we used them
        this.ctx.fillRect(0, 0, this.canvas.width, this.canvas.height);
        
        // Background Grid (Retro effect)
        this.ctx.strokeStyle = '#1a1a1a';
        this.ctx.lineWidth = 1;
        this.ctx.beginPath();
        for(let x=0; x<GAME_WIDTH; x+=40) { this.ctx.moveTo(x,0); this.ctx.lineTo(x,GAME_HEIGHT); }
        for(let y=0; y<GAME_HEIGHT; y+=40) { this.ctx.moveTo(0,y); this.ctx.lineTo(GAME_WIDTH,y); }
        this.ctx.stroke();

        // Draw Paddle
        this.ctx.shadowBlur = 15;
        this.ctx.shadowColor = COLORS.paddle;
        this.ctx.fillStyle = COLORS.paddle;
        this.roundRect(this.paddle.x, this.paddle.y, this.paddle.width, this.paddle.height, 8);
        
        // Draw Ball
        this.ctx.shadowBlur = 10;
        this.ctx.shadowColor = COLORS.ball;
        this.ctx.fillStyle = COLORS.ball;
        this.ctx.beginPath();
        this.ctx.arc(this.ball.x, this.ball.y, this.ball.radius, 0, Math.PI * 2);
        this.ctx.fill();

        // Draw Bricks
        for (let b of this.bricks) {
            if (b.status === 1) {
                this.ctx.shadowBlur = 10;
                this.ctx.shadowColor = b.color;
                this.ctx.fillStyle = b.color;
                this.ctx.fillRect(b.x, b.y, b.w, b.h);
                
                // Bevel effect
                this.ctx.shadowBlur = 0;
                this.ctx.fillStyle = 'rgba(255,255,255,0.2)';
                this.ctx.fillRect(b.x, b.y, b.w, b.h/2);
            }
        }

        // Draw Particles
        for (let p of this.particles) {
            this.ctx.globalAlpha = p.life;
            this.ctx.fillStyle = p.color;
            this.ctx.shadowBlur = 5;
            this.ctx.shadowColor = p.color;
            this.ctx.beginPath();
            this.ctx.rect(p.x, p.y, p.size, p.size);
            this.ctx.fill();
        }
        this.ctx.globalAlpha = 1.0;
        this.ctx.shadowBlur = 0;
    }

    roundRect(x, y, w, h, r) {
        if (w < 2 * r) r = w / 2;
        if (h < 2 * r) r = h / 2;
        this.ctx.beginPath();
        this.ctx.moveTo(x + r, y);
        this.ctx.arcTo(x + w, y, x + w, y + h, r);
        this.ctx.arcTo(x + w, y + h, x, y + h, r);
        this.ctx.arcTo(x, y + h, x, y, r);
        this.ctx.arcTo(x, y, x + w, y, r);
        this.ctx.closePath();
        this.ctx.fill();
    }

    loop(timestamp) {
        const dt = timestamp - this.lastTime;
        this.lastTime = timestamp;

        this.update(dt);
        this.draw();
        requestAnimationFrame(t => this.loop(t));
    }

    updateHUD() {
        this.scoreEl.innerText = this.score;
        this.livesEl.innerText = this.lives;
    }

    hideOverlays() {
        [this.startScreen, this.gameOverScreen, this.victoryScreen].forEach(el => el.classList.add('hidden'));
    }
}

// Start Game Instance when DOM is ready
window.onload = () => {
    const game = new Game();
};

</script>
</body>
</html>
